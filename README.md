## 즐거운 자바 04 -  new 연산자와 인스턴스, static 키워드와 Hello 실행순서

- int 초기값은 0
- boolean 초기값은 false
- 객체가 메모리에 올라간 것을 인스턴스라고 한다.
- 클래스는 하나지만, 해당 클래스 때문에 메모리가 부족하여 죽을 수 있다.
  - for문으로 객체생성



### Hello class가 실행되기까지의 과정

1. 자바프로그램은 실행되려면 가져야 되는 메소드 : public static void main(String[] args)
2. java Hello [enter]   <---------- enter를 하게 되면 hello가 가지고 있는 static을 특별취급해서 메모리에 올려준다.

- java : JVM이 class를 읽어들이고 실행한다.
- 환경변수 설정 **CLASSPATH**의 값으로 .   .은 무엇을 의미할까요?  // 현재 폴더
- 만약 **CLASSPATH**의 값으로 C:/tmp 라고 설정되어있다 Hello 클래스를 어디서 찾을까요? // c:tmp 폴더

1. 디스크에서 Hello라는 클래스를 찾았다면 Hello 클래스를 사용하기 위하여 일겅 들입니다. 읽어 들일 때 static이라고 붙어 있는 것들은 특별 취급을 하게 됩니다. Hello 클래스는 어떤 부분에 static 이라는 단어가 붙어있나요?

   네 바로 아래와 같이 main 이라고 부르는 메소드에 static 이 붙어 있는 것을 학인 할 수 있습니다.

```java
public class Hello{
    public static void main(String[] args){
       System.out.println("Hello!!");
   }
}  

```

   JVM 은 Hello 의 main 메소는 특별 취급하게 됩니다. 여기서 특별취급이라 실행 가능하도록 메모리에 올려준다는 것입니다. 즉 Hello 클래스가 가지고 있는 모든 것들이 메모리에 올라가는 것이 아니라 Hello의 main메소드가 실행 가능하도록 메모리에 올라간다는 것을 의미합니다.

만약 Hello가 3개의 메소드를 가지고 있고, 3개의 메소드에 모두 static이 붙어 있다면 3개의 메소드가 모두실행 가능하도록 메모리에 올라가게 됩니다.



JVM은 Hello 클래스를 읽어 들인 후 Hello 클래스가 가지고 있는 메소드 중 static이라고 붙어 있는 것은 실행 가능하도록  합니다.

그리고 나서 JVM은 static 한 메소드 중에서 String 배열을 받아들이는 main 메소드를 찾습니다. main 메소드를 찾았다면 main메소드를 한 줄 한 줄 실행해 나갑니다.

main 메소드를 찾을 수 있는 이유는 메인메소드가 static하기 떄문에 메모리에 올라가 있기 때문에 찾을 수 있습니다.



##### 자바에서 메로리에 올리는 방법은 크게 2가지 방법이 있음

- new 클래스이름():  메모리에 인스턴스가 만들어진다.
- 클래스가 가지고 있는 필드나 메소드에 static을 붙여준다.
  특별취급. 메소드에 static이 붙어 있으면 실행가능.
  - 프로그램은 실행되려면 메모리에 올라가야 된다.
    메모리에 올라가 있지 않으면 실행할 수 없다.
    클래스를 사용하려면 인스턴스를 만들어줘야 한다.



##### 인스터스로 메모리에 올리는거와 static으로 메모리에 올리는 것의 차이는?

```java
Bus b1 = new Bus();
Bus b2 = new Bus();

b1.버스가 가지는 기능();
b2.버스가 가지는 기능();

//인스턴스가 없어도 어떤 기능을 사용하고 싶다.

public class Bus(){
    public static void ppangppang(){
        
    }
}
// 인스턴스를 만들지 않아도 기능을 사용할 수 있다.
Bus.ppangppang();
```

##### 클래스 선언문 자체는 메모리에 올라가나요??  즉 실행 파일에 포함이 되는건가요? 클래스 선언문 역시 소스코드의 용량을차지하니까 궁금합니다.

- 소스코드가 메모리가 올라가지 않는다. 클래스에 대한 정보가 딱 한 번 올라간다.
- 클래스에 대한 정보는 Perm이라는 영역에 딱 한 번 올라간다.(Perm은 자바가 관리하는 메모리영역임)





java Hello
Hello.main <--- static. 실행 가능하도록 메모리에 올린다.

만약 Hello가 다른 메소드를 가지고 있고, 해당 메소드가 static이 붙어 있으면 그 메소드도 실행가능하도록 메모리에 올라갈 것이다.

JVM은 static한 메소드 중에서 main(String[]) 메소드를 찾아서 실행한다. 그리고 난후 JVM은

main메소드를 찾아서 한줄 한줄 실행한다.(인터프리터 방식)



```java
java Hello 안녕하세요 홍길동 [enter] // 메인 메소드의 파라미터로 들어간다. 프로그램 아규먼트(실행할때 넣어주는 것) : 홀길동 안녕은 프로그램 아규먼트이고 String[] 스트링 배열이다.

public static void main(String[] args){
    System.out.println("Hello!!");
}
```

main메소드를 실행할 때 String을 발견!!!!
JVM은 String클래스를 찾아서 읽는다.
String이 static한 것들을 가지고 있는지 본다.
즉 String 인스턴스가 만들어지기 전에 static한 것들은 미리 사용가능하게 됩니다.

인스턴스보다 static한 것들은 무조건 먼저 메모리에 올라간다.
그 클래스가 발견되고 읽혀질때 올라간다

System 을 발견!!! System이 가지고 있는 무엇을 특별취급? static

System.out이 통째로 메모리에 올라간다. out은 printStream이라는 Class임.

System.out.println("Hello!!");

System이 가지고 있는 static한 필드 out

그 static한 필드 out이 가지고 있는 println이라는 기능을 사용

```java
class System{
    static PrintStream out = new ....(); //초기화
}
```





## 즐거운 자바05 - 다른 사람이 만든 클래스 사용하기, package, import, 클래스 변수와 인스턴스 변수



### 다른 사람이 만든 클래스 사용하기(Random, Math)



- 자바도 java 파일 -> 컴파일 -> class 파일

  class 파일도 많아진다.

  class도 폴더 별로 관리할 필요가 있다

  한 폴더에 같은 이름의 파일이 여러개 있을 수 있나?

  자바를 만든 사람들은 클래스를 관리하기 위해여 package라는 개념을 만들었다.
  package = 폴더

- class를 만들 때 package 이름을 kr.co.sunnyvale.first
  컴파일이 될 때 kr폴더 - co폴더 - sunnyvale폴더 - first 폴더 - class 파일 생성

  - package가 있을 경우 컴파일 할 때 -d 라는 옵션을 넣어준다.

    ```java
    javac Hello.java // 피키지가 없을 경우
    javac -d 폴더명 Hello.java // 패키지가 있을 경우 -d
    javac -d c:\tmp Hello.java
    
    c:\tmp 디렉토리에 kr - co - sunnyvale -first - Hello.java
    ```




- package는? 폴더
  보통의 경우 도메인 이름을 거꾸로 + 프로젝트명
  package가 있을 경우 컴파일 할 떄 -d 옵션으로 패키지가 생성될 경로를 지정한다.



- 자바가 기본으로 제공하는 package 중에서 초보자들이 꼭 봐야 할 package?

  - java.lang - 기본이 되는 package (import 하지 않아도 사용할 수 있다.)
  - java.util - 유용한 class - 날짜, 자료구조 ....
  - java.io - 입출력
  - java.net - 네트워크




- import 라는 것은 사용하는 클래스가 어떤 패키지에 있느냐라는 것을 JVM과 컴파일러에게 알려준다. 
  - java.lang 패키지에 있는 클래스들은 import하지 않아도 사용가능



#### Constructor ( 생성자 )

- 생성자 : 인스턴를 생성.
  Book book = new Book();



- 생성자는 왜 중요? 

  - 어떤 클래스를 사용하려면 인스턴스를 만들어야 한다. 

- Random Constructor

  ```java
  - Random()
  Create a new random number generator.
  
  - Random(long seed)
  Creates a new random number generator using a single long seed.
  ```

  - import java.util
    Random r1 = new Random();  // 인스턴스를 만들어야 사용가능
    r1.메소드();



- Random 예제

  ```java
  public class RandomTest {
      
      public static void main(String[] args){
          // ctrl + shift + o
          Random r= new Random();
          
          // r.nextInt(6)     -->     0 <= x < 5
          // r.nextInt(6) + 1 -->     1 <= x < 6
          int dice = r.nextInt(6) + 1;
          System.out.println(dice);
      }
  }
  ```

- static 이 붙어 있지 않은 메소드는 반드시 인스턴스를 만들고, 그 인스턴스를 참조하는 참조 변수를 통하여 사용



- Math

  - 생성자에 대한 설명이 api에 없다 - 생성자가 없는 class는 없다.
  - 생성자를 사용못하게 하는 class 는 있다. -> private 생성자를 가지고 있으면 사용불가.
    private 생성자는 api설명서에 나오지 않는다.
  - import java.lang.Math; // <----  삽입할 필요가 없다.
    Math m =  new Math(); // 컴파일 오류

  ```java
  public class MathText {
      
      public static void main(String[] args){
          
          // static메소드는 Class이름.메소드(); 이런 형식이다.
          // 기본적으로는 Class를 사용하려면 인스턴스를 만들고 사용해야한다.
          // 0.0 <= x < 1.0
          double rand = Math.random();
          // 0.0 <= x < 6.0
          rand = rand * 6;
          // (int) 로 형변환 - 정수 -> 잘림
          // 0 <= x < 6
          int irand = (int) rand;
          // 1 <= x < 7
          int dice = irand + 1;
          
          System.out.println(rand);
          
          int dice2 = (int)(Math.random() * 6) + 1;
          System.out.println(dice2);
      }
  }
  ```


### 모든 공부는 반복 훈련



### 클래스 변수와 인스턴스 변수

- 클래스 가지는 것 - 필드, 메소드

  - 필드 -> 클래스 변수(static이 붙어 있다), 인스턴스 변수

  **꼭 기억하자!!**
  static은 인스턴스가 만들어지기 전에 딱 한 번만 메모리에 올라간다.
  인스턴스(메모리에 올라감)는 언제 만들어지는가?  new 생성자();
  인스턴스가 만들어지지 않아도 static하다고 써있는 애들은 미리 클래스가 발견되는 순간 static한 것들은 미리 메모리에 올라간다.

```java
package kr.co.ksunnyvale.first;

public class MyBean {
    // class 변수
    static int staticValeu;
    
    // 인스턴스 변수 
    int instanceValue;
}
```



```java
package kr.co.ksunnyvale.first;

public class MyBeanTest {
    
    public static void main(String[] args) {
        // 같은 package에 있는 클래스는 import할 필요가 없다.
        // MyBean이 가지고 있는 클래스변수는 특별 취급 -> 사용할 수 있또록 미리 메모리에 올라간다. 아직 생성사 실행전
        // 같은 클래스는 디스크에서 딱 한번 만 읽어들인다.
        // 한 번 읽어들인 클래스 정보는 메모리에 올라가 있고,
        // 두번쨰 부터는 메모리에 있는 클래스 정보를 사용한다.
        // 1) MyBean.staticValue 는 미리 메모리에 올라간다.
        // 2) MyBean인스턴스가 만들어지고 이 인스턴스를 사용할 수 있는 
        //    bean1 참수변수가 만들어진다.
        MyBean bean1 = new MyBean();
        // 3) MyBean인스턴스가 만들어지고 이 인스턴스를 사용할 수 있는 
        //    bean2 참조변수가 만들어진다.
        MyBean bean2 = new MyBean();
        MyBean.staticValue = 5;
        System.out.println(MyBean.staticValue); // 5
        
    }
}
```



- package는 디렉토리
  kr.co.sunnyvale.first : package이름
  MyBean이라는 클래스가 해당 package가 있다.

  위의 클래스를 다른 클래스에서 사용하려면
  import kr.co.sunnyvale.first.MyBean;

  c:\tmp

  ​	-- kr
  ​		--- co
  ​			--- sunnyvale
  ​				--
  ​				first
  ​				---MyBean

  CLASSPATH=c:\tmp





## 즐거운 자바06 - 객체지향이란? 1/3



### 객체지향 개요

- **이름이 가지는 직관성**
  -  객체지향에서 가장 중요한 것은 무엇입니까?   // 이름
      이름만 봐도 무엇을 가지고 있는지 어떤 기능을 가지고 있는지 알 수 있다.
      이름을 봐도 모른다는 것은? 그것에 대한 경험이 없다.
      알아야지만 이름을 보고 이해를 할 수 있다.
      알아야지만 직관성이 생긴다. 

1. **추상화, 응집도** 

   - 추상화 : 중요한 것은 남기고 불필요한 것은 삭제한다.
     - 어디서의 고객이냐에 따라서 고객이 가지는 속성이 중요도가 달라진다
     - 재상용은 어렵다. 업무와 관련된 것은 재사용이 어렵다
       - 도서대여점
       - 신발가게
     - 도서대여점이 망할 것 같으니깐...  미리 신발사이즈를 넣어 놓겠다 ---> 이러면 안된다.
       - 객체지향을 한다는 것은 현실것만 집중하는 것이다. 미래는 아니다
   - 응집도 : 관련된 것을 잘 모아서 가지고 있다.
     - Math - 이름이 중요. 직관! 수학과 관련된 것을 잘 모아서 가지고있겠다.
       - Mat안에 있는 것을 다 외울 필요가 없다.
       - 당연히 Math에는 이러이러한 것이 있겠지? 접근



   **추상화, 응집도, 이름 ---- '객체는 역할이 있다. 책임도 있다'**

   - 알바의 역할이 있다는 것은, 알바에 대한 책임도 있다.



   **좋은 객체란 무엇인가? - 응집도는 높고, 결합도는 낮다**

   - 잘 추상화 되어있고
   - 잘 모아져야 있고
   - 이름도 잘 적혀있고

2.  **오버로딩(Overloading)**

   - 무엇을 먹었어요?
     밥버거를 먹었습니다.
     보쌈을 먹었습니다.
     장조림을 먹었습니다.

     000를 먹었습니다.


   - C언어
     plusint(int, int) - 함수
     plusfloat(float, float) - 함수
     C언어의 경우 파라미터의 수가 달라지거나, 파라미터의 type이 다르면 이름이 다른 함수를 만들어야 한다.

3. - 더하다! - 파라미터의 수가 달라지거나, 파라미터의 type가 다르다면 같은 이름으로 메소드를 여러개 만들 수 있다.  ---> 오버로딩

      

     - println을 여러개 만든 개발자는 피곤하였을꺼다. 하지만 사용하는 사람은 편하다.
     - 만드는 사람은 어렵게만들더라도, 사용하는 사람은 쉽게 사용한다.



**객체지향 프로그래밍이란?**

3. 도서 대여점에 존재하는 객체들

   - 도서 대여점에서 책을 관리하는 것은 누구?

   - 도서 대여점에서 고객을 관리하는 것은 누구?

   - 도서 대여점에서 돈을 관리하는 것은 누구?

   - 미녀와 야수 에니메이션 ~~ 야수의 성에 등장하는 인물은 누구?
     마법에 걸린 물건들....

     도서대여점도 야수의 성처럼 마법에 걸렸다.
     모든 물체가 살아있다.

      도서대여점엔 여러가지 물체가 있다.

      책장은 무엇을 가지고 있는가? 책을 가지고 있다.
      책장의 역할? -- 책을 관리하려면 책장

      책장아 너 책 몇 권 가지고 있어?
      금고에게 질문하기않고 책장에게 질문하는 것은 책장이 책을 가지고 있으니 책이 몇권 가지고 있는지 알려줄 수 있다고 기대한다.

      책은 무엇을 가지고 있느냐?
      책에게 너 제목이 뭐야?

      도서대여점의 모든 물체들이 살아 있다면.. 그 물체들은 모두 중요할까? 도서대여점을 관리하는 입장으로 봤을때?

      도서대여점 관리 프로그램을 만든다면...

      도서대여점 주인이 하는 일을 편하게  - 업무

      책을 관리하는 것은 누구? 책장
      고객을 관리하는 것은 누구? 고객장부
      돈을 관리하는 것은 누구? 금고

      객체지향프로그램 - 현실 세계를 그대로 프로그래밍으로 옮기는 것

     **현실 세계의 업무를 컴퓨터 세상에 맞도록 재창조 하는 것**

     책장 -> BookService 클래스
     고객명부 -> UserService 클래스

4. 현실 세계를 그대로 옮기는 것이 객체지향이다. 과연?

   - 현실 세계의 업무를 컴퓨터 세상에 맞도록 재창조 하는 것



5. 역할, 책임, 협력

   속성 ---> 필드
   기능 ---> 메소드

   - 협력 : 객체와 객체는 관계를 맺고 있다. 그래서 서로서로가 도와준다.
     - Sort를 하는 클래스가 있다면, 값을 비교하는 기능을 가지고 있는 클래스는 사용할 수 도 있다.

6. **has a 관계** :  속성(필드)  - 가지는 관계 (association 관계)



   선풍기 -----> -wing   날개   - 선풍기는 날개를 가진다. 



   선풍기

   wing : 날개

   on() : void







   Book

   price : int
   titile : String

   getTitle() : String
   setTitle() : void



​	어떤 기능이 사용될 때 다른 클래스가 사용된다면 이건 보통 의존한다.  - **Dependency관계**

​	PrintWriter             

​	println(String) : void    -----> String 



​	할아버지

​	걷다(지팡이): void    ------> 지팡이

​	메소드 안에서 사용되는 클래스들은 모두 의존관계이다. 여기서는 String만 보이지만
​	가지는 관계가 아닌데 메소드안에서만 사용되면 의존관계이다. 
​	가장많이 쓰이는 관계가 의존관계이다.  - 중요한 것만 표현한다.





7. 일반화, 확장, 추상클래스 그리고 상속 관계

   -  클래스는 객체를 만들기 위한 틀   ----> 인스턴스(객체)
       포유류 중에서 좋아하는 포유류 이름

     내일 점심에 먹고 싶은 음식의 이름

     포유류라는 단어는 실제 세상에 존재하는 것인가?
     사자는 존재하는데....



     포유류를 그리시오. 누군가에게 시켰을 때 그 결과가 다양하게 나온다면
     포유류는 구체적인 것이 아니다. 구체적인 것은 포유류라고 불리는 사자, 코끼리, 고래가 구체적인 것이다.
     사자, 코끼리, 고래 등을 일반화시켜서 부르는 단어가 포유류 



   단어로써는 존재하지만 실제로 인스턴스는 없는 것들은 우리가 그것을 추상클래스라고 말한다.
   단어는 있지만, 인스턴스다 ---> 가구, 전자제품 등

   ​		

   버스는 자동차다

   혹은 버스는 자동차의 한 종류다

   - 여러가지 있을 때 여러가지 것들에 대한 공통적인 개념을 뽑아서 하나로 부를 수 있다면 일반화 시키는 것
     - 버스, 트럭, 스포츠카 등에서 공통적인 개념을 뽑아서 자동차라고 부른다면 일반화

   - 반대로 자동차라는 단어를 보고 뒤에다 짐을 실고 흙을 싣는 것을 만들자  그럼 트럭이 될 수 있겠죠

     - 자동차 ---> 버스 or 트럭 이라는 개념이 등장한다면 확장



     일반화 + 확장 =======> 상속(  is a )
    
     - ~은 ~ 이다. 라는 개념적인 관계가 되어야만 상속을 사용 할 수 있다.



     많은 클래스를 보고 공통적인 것을 뽑아서 일반적인 클래스를 만들었다면   :: 상속
    
     어떤 클래스를 보고 개념을 확장시켜서 클래스를 만들었다면 : 상속
    
     위에 있는 것은 부모클래스
    
     아래에 있으면 자식클래스
    
     ​	
    
     자동차 c = new 자동차(); // 틀림 구체적인 모양이 없기때문에 실제 존재할 수 없다. 단어만 존재함.
    
     버스 b = new 버스(); // 버스인스턴스를 만들고, 저건 버스 b라고 부르자



   ​	버스가 있는데, 해당 버스를 가리키면서 자동차네~~

   ​	자동차 c = new 버스(); // 버스 인스턴스를 만들고, 자동차 c라고 부르자





   ​		   자동차

​	버스 	스포츠카 	트럭	

​	이층 버스





## 즐거운 자바07 - 객체지향이란? 2/3

- 상속?
  일반화 + 확장  == 상속

  자식을 보고                              부모를 도출

  버스, 트럭,  스포츠카 --------> 자동차라고 부르자 ( 일반화 )

  ​	-----------------------------------------

  부모 + 새로운것 --------> 자식

​	자동차 + 짐 ------------> 트럭( 확장 )



- 자동차라는 클래스는 개념만 있고, 인스턴스를 만들 수 없다면 -----> 추상클래스

```java

// 자동차는 추상클래스다.
public abstract class 자동차 {
    public void 달리다(){
        System.out.println("전륜구동으로 달리다");
    }
}

```

```java
// 자동차를 상속받고 있는 버스
public class 버스 extends 자동차 {
    public void 안내방송(){
        System.out.println("안내방송~");
    }
} 
```

```java
public class 이층버스 extends 버스 {
    
}
```

```java
public class 스포츠카 extends 자동차 {
    public void 터보() {
        System.out.println("터보!!")
    }
}
```

```java
public class 트럭 extends 자동차 { 
	
}
```



상속 관계 - is a, kind of,

- 트럭은 자동차다
  버스는 자동차다
  트럭은 자동차의 한 종류다
  버스는 자동차의 한 종류다.
- Stack - FILO 자료구조, 
- List - 순서가 있고, index에 해당하는 것을 꺼낼 수 있다, 순서를 기억한다.
  - Vector(리스트 형 자료구조)



Stack은 Vector다. == (Stack은 Vector를 상속받는다.)   // 같은말을 하는 것임  //자바에서 잘 못 구현! JDK 1.0 때 잘못구현 함.



**상속! 문법보다도 더 중요한 것은 개념.**
**is a 관계가 안 된다면 상속을 받으면 안 된다.**



api에

//자동차나 자동차의 후손들이 들어갈 수 있다.

// 아 자동차는 인스턴스가 될 수 없구나 그래서 자동차의 후손만 들어갈 수 있구나

public void 주차(자동차 c)



// Action이나 Action의 후손들
public void exec(Action a)



노트북은 컴퓨터다
(자식)       (부모)

```java
public class Test {
    public static void main(String[] args){
        버스 b1 = new 버스();
        b1.달리다(); // 부모가 가지고 있는 메소드
        b1.안내방송();
        
        자동차 c1 = new 자동차();  // 추상클래스여서 자동차는 인스턴스가 될 수 없다.
        
        //버스가 있다. 해당 버스를 가리키면서 자동차다! (0)
        
        // 별표 10개
        //암기 : 조상타입의 참조변수로 후손 인스턴스를 가리킬수 있다.
        자동차 c2 = new 버스();
        c2.달리다();
        
        // 장점은???
        자동차 c3 = new 스포츠카(); // 주차요원이 스포츠카를 사용할 때 
        스포츠카 c4 = new 스포츠카(); // 주인이 스포츠카를 사용할 때
        
        
        
        
    }
}
```

```java
public class 주차장 {
    // 자동차는 추상class 인스턴스가 될 수 없다.
    // 주차메소드에 자동차는 못들어온다.
    // 자동차라고 불리는 것들(자동차의 자식들)이 들어올 수 있다.
    public void 주차(자동차 c){
        c.달리다();
    }
    
    // 이메소드는 자동차는 추상클래스니깐 자동차의 후손이 나오는 클래스야
    public 자동차 get() {
        return new 스포츠카();
    }
}
```



**조상type으로 후손인스턴스를 참조할 수 있다.**

A a = new C(); // 이 관계가 오류가 나지 않으면 A와 C는 조상(A)과 후손(B)관계

A <---- 무언가 <---- c  // A는 C의 조상클래스이거나 A는 C의 부모이거나



**자바는 아무것도 상속받지 않으면 자동으로 Object를 상속 받는다**

Object obj = new 이층버스();  // (0)



```java
public class 만능상자{
    private Object obj;
    
    public void set(Object o){
        // 버스를 넣어줘도 Objecr가 가지는 메소드만 사용가능.
        obj = o;
    }
    
    public Object get(){
        return obj;
    }
}
```

```java
public class Test2 {
    
    public static void main(String[] args){
        만능상자 box = new 만능상자();
        
        버스 b = new 버스();
        
        box.set(b); // 오류가 안나는 이유? o
        
        // 형변환을 하지 않으면
        // box에서 나온 것은 버스이지만
        // Object가 가지고 있는 메소드만 사용가능.
        Object obj = box.get();
        // 형변환하여 꺼내고 있다.
        // 원래 넣었던 것이 버스라서 가능!
        버스 b2 = (버스) box.get();
    }
}
```



스포츠카 c = new 버스(); // (x)

자동차 c = new 이층버스(); // (o)



# 별100개

## **조상type으로 후손인스턴스를 참조할 수 있다.**

- 자동차 c = new 스포츠카(); // 자동차가 가지는 메소드만 사용가능
- 앞에 참조변수는 사용할 수 있는 메소드를 결정 해줌

## **메소드가 오버라딩 되면 무조건 자식의 메소드가 사용된다**

- c.달리다(); // 달리다가 오버라딩 되어 있다면 자식의 메소드가 사용된다.
- 오버라딩 되어 있다면 자식 메소드가 사용됨

```java
public class Test3 {
    public static void main(String[] args){
        자동차 c  = new 스포츠카();
        
        스포츠카 s = new 스포츠카();
        s.달리다(); // 후륜구동으로 달리다 /(아래 오버라드를 했기 때문에)
        s.터보();
        
        // 눈앞에 스포츠카가 있다.
        // 이 스포츠카를 가리키면서 자동차다.
        자동차 c = new 스포츠카();
        
        // 이어서, 그 자동차는 달린다.
        // 그 자동차는 전륜구동? 후륜구동?
        // 자동차
        c.달리다(); // 후륜구동으로 달리다 --> 사용할 수 있는 메소드는 자동차가 가지고 있는 메소드만 사용 할 수 있지만 메소드가 오버라이딩 되어있으면 실제사용되는 것은 오바라이딩 된 메소드가 사용이 됩니다.
        // c.터보();  --> 사용할 수 없다. 자동차 c이기 떄문에
    }
}
```

```java
public class 스포츠카 extends 자동차 {
    public void 터보() {
        System.out.println("터보!!");
    }
    
    // 메소드 이름이 같고, 파라미터의 수, 파라미터의 타입이 
    // 모두 같다면 오버라이딩. -- 중복되어 구현되다. 대채하는 것이 아니다.
    public void 달리다() {
        System.out.println("후륜구동으로 달리다");
    }
}
```





어떤 기능을 만들건인가? 고민? vs 구현부터 한다?  전자

---> 기능은 메소드를 의미함



어떤 기능을 구현할 것인가? 를 정하는 것이 중요하다 == 요구사항을 파악하는 것
고객이 필요로 하는 기능을 만든다. 기능고민부터 고민

자바에서는 기능을 선언 하는 방법으로 interface라는 문법을 제공한다.
초보자들은 이 interface가 어렵다. -- 기능을 도출하는 것! <-- 힘들다 초보자들은

사칙연산 프로그램
첫번째 : 더하기, 빼기, 곱하기, 나누기 기능이 필요하겠다. - **기능선언**(인터페이스)
두번째: 위의 기능을 구현한다. - 기능구현(클래스)

**인터페이스와 클래스의 관계는 구현의 관계**

엄밀히 말하면 인터페이스가 없다는 것은 생각이 없는 것. - 

- 인터페이스가 없다는 것은 기능구현을 미리 안하겠다는 이야기이기 때문임
- 기능을 미리 구현하겠다는 계획이 없었기 때문에



**인터페이스와 클래스의 관계는 구현의 관계**
**추상클래스와 클래스의 관계는 상속관계 - is a 관계 ( 개념이 틀리다)**

추상클래스는 클래스이긴 하지만 인스턴스가 안되어야 하는 경우에 추상클래스를 정의하는 것이고
인터페이스는 기능을 정의하는 것이다.  완전히 목표가 달라요.



자바라를 만든 사람들은 C++의 어려움 점, 포인터, 다중상속을 없앰
어떤 언어를 공부하시든. 그 언어의 철학에 맞도록 공부.

부모 클래스는 일반화한다. 자식클래스의 공통적을 뽑아서 부모클래스를 만든다.
이렇게 만들어진 부모클래스가 개념적으로 인스턴스가 되면 안된다. 그렇기 떄문에 추상클래스가 된다.
부모클래스가 인스턴스가 되도 된다고 해도 상관없으면 추상클래스가 아닌거죠
그러면서 개념적으로 부모가 가지고 있는 메소드가 있는데 이 메소드가 미리 구현될 필요가 없다.



경험! 많이 프로그래밍하고 설계한다. 개발은 설계의 완성을 위해 간다.
설계 -> 개발> 설계에 반영 -> 개발 반복작업
수정하는 작업을 리펙토링이라고 한다. 기존에 잘 돌아갔었는데 수정하고 나서도 잘 돌어가야 한다. Test와 함께 다닌다.



숙제 : TDD간단 조사 ~~ JUnit 이라는 것도 간단한 예제